use std::collections::HashMap;
use std::io::{BufRead, BufReader, Write, Read};
use std::process::{Child, Command, Stdio};
use std::sync::Mutex;
use std::time::{SystemTime, UNIX_EPOCH};

use crate::models::server::*;

const DATA_FILE: &str = "sea_lantern_servers.json";

pub struct ServerManager {
    pub servers: Mutex<Vec<ServerInstance>>,
    pub processes: Mutex<HashMap<String, Child>>,
    pub logs: Mutex<HashMap<String, Vec<String>>>,
    pub data_dir: Mutex<String>,
}

impl ServerManager {
    pub fn new() -> Self {
        let data_dir = get_data_dir();
        let servers = load_servers(&data_dir);
        let mut logs_map = HashMap::new();
        for s in &servers { logs_map.insert(s.id.clone(), Vec::new()); }
        ServerManager {
            servers: Mutex::new(servers),
            processes: Mutex::new(HashMap::new()),
            logs: Mutex::new(logs_map),
            data_dir: Mutex::new(data_dir),
        }
    }

    fn save(&self) {
        let servers = self.servers.lock().unwrap();
        let data_dir = self.data_dir.lock().unwrap();
        save_servers(&data_dir, &servers);
    }

    fn get_app_settings(&self) -> crate::models::settings::AppSettings {
        super::global::settings_manager().get()
    }

    pub fn create_server(&self, req: CreateServerRequest) -> Result<ServerInstance, String> {
        let id = uuid::Uuid::new_v4().to_string();
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let jar_path_obj = std::path::Path::new(&req.jar_path);
        let server_dir = jar_path_obj.parent()
            .map(|p| p.to_string_lossy().to_string())
            .unwrap_or_else(|| ".".to_string());

        let server = ServerInstance {
            id: id.clone(), name: req.name, core_type: req.core_type,
            core_version: String::new(), mc_version: req.mc_version,
            path: server_dir, jar_path: req.jar_path, java_path: req.java_path,
            max_memory: req.max_memory, min_memory: req.min_memory,
            jvm_args: Vec::new(), port: req.port, created_at: now, last_started_at: None,
        };
        self.servers.lock().unwrap().push(server.clone());
        self.logs.lock().unwrap().insert(id, Vec::new());
        self.save();
        Ok(server)
    }

    pub fn import_server(&self, req: ImportServerRequest) -> Result<ServerInstance, String> {
        let source_jar = std::path::Path::new(&req.jar_path);
        if !source_jar.exists() {
            return Err(format!("JAR file not found: {}", req.jar_path));
        }

        // 在软件目录下创建服务器文件夹
        let id = uuid::Uuid::new_v4().to_string();
        let data_dir = self.data_dir.lock().unwrap().clone();
        let servers_dir = std::path::Path::new(&data_dir).join("servers");
        let server_dir = servers_dir.join(&id);

        // 创建服务器目录
        std::fs::create_dir_all(&server_dir)
            .map_err(|e| format!("无法创建服务器目录: {}", e))?;

        // 复制JAR文件到服务器目录
        let jar_filename = source_jar.file_name()
            .ok_or_else(|| "无法获取JAR文件名".to_string())?;
        let dest_jar = server_dir.join(jar_filename);

        std::fs::copy(source_jar, &dest_jar)
            .map_err(|e| format!("复制JAR文件失败: {}", e))?;

        println!("已复制JAR文件: {} -> {}", req.jar_path, dest_jar.display());

        let server_properties_path = server_dir.join("server.properties");
        let server_properties_content = format!(
            "# Minecraft server properties\n\
             # Generated by SeaLantern\n\
             server-port={}\n\
             online-mode={}\n",
            req.port,
            req.online_mode
        );
        std::fs::write(&server_properties_path, server_properties_content)
            .map_err(|e| format!("创建 server.properties 失败: {}", e))?;

        println!("已创建 server.properties: {}", server_properties_path.display());

        // 创建服务器实例
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let server = ServerInstance {
            id: id.clone(),
            name: req.name,
            core_type: "unknown".into(),
            core_version: String::new(),
            mc_version: "unknown".into(),
            path: server_dir.to_string_lossy().to_string(),
            jar_path: dest_jar.to_string_lossy().to_string(),
            java_path: req.java_path,
            max_memory: req.max_memory,
            min_memory: req.min_memory,
            jvm_args: Vec::new(),
            port: req.port,
            created_at: now,
            last_started_at: None,
        };

        self.servers.lock().unwrap().push(server.clone());
        self.logs.lock().unwrap().insert(id, Vec::new());
        self.save();
        Ok(server)
    }

    pub fn import_modpack(&self, req: ImportModpackRequest) -> Result<ServerInstance, String> {
        let source_path = std::path::Path::new(&req.modpack_path);
        if !source_path.exists() {
            return Err(format!("整合包文件夹不存在: {}", req.modpack_path));
        }
        if !source_path.is_dir() {
            return Err("所选路径不是文件夹".to_string());
        }

        // 查找服务端JAR文件
        let source_jar = find_server_jar(source_path)?;
        println!("找到服务端JAR文件: {}", source_jar);

        // 在软件目录下创建服务器文件夹
        let id = uuid::Uuid::new_v4().to_string();
        let data_dir = self.data_dir.lock().unwrap().clone();
        let servers_dir = std::path::Path::new(&data_dir).join("servers");
        let server_dir = servers_dir.join(&id);

        // 创建服务器目录
        std::fs::create_dir_all(&server_dir)
            .map_err(|e| format!("无法创建服务器目录: {}", e))?;

        // 复制整合包文件夹的所有内容到服务器目录
        println!("正在复制整合包文件: {} -> {}", source_path.display(), server_dir.display());
        copy_dir_recursive(source_path, &server_dir)
            .map_err(|e| format!("复制整合包文件失败: {}", e))?;

        // 获取复制后的JAR文件路径
        let jar_filename = std::path::Path::new(&source_jar)
            .file_name()
            .ok_or_else(|| "无法获取JAR文件名".to_string())?;
        let dest_jar = server_dir.join(jar_filename);

        if !dest_jar.exists() {
            return Err(format!("复制后的JAR文件不存在: {}", dest_jar.display()));
        }

        // 创建服务器实例
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
        let server = ServerInstance {
            id: id.clone(),
            name: req.name,
            core_type: "modpack".into(),
            core_version: String::new(),
            mc_version: "unknown".into(),
            path: server_dir.to_string_lossy().to_string(),
            jar_path: dest_jar.to_string_lossy().to_string(),
            java_path: req.java_path,
            max_memory: req.max_memory,
            min_memory: req.min_memory,
            jvm_args: Vec::new(),
            port: req.port,
            created_at: now,
            last_started_at: None,
        };

        println!("创建服务器实例: id={}, path={}, jar_path={}", server.id, server.path, server.jar_path);

        self.servers.lock().unwrap().push(server.clone());
        self.logs.lock().unwrap().insert(id, Vec::new());
        self.save();
        Ok(server)
    }

    pub fn start_server(&self, id: &str) -> Result<(), String> {
        let server = {
            let servers = self.servers.lock().unwrap();
            servers.iter().find(|s| s.id == id)
                .ok_or_else(|| "未找到服务器".to_string())?.clone()
        };

        println!("准备启动服务器: id={}, name={}, jar_path={}, java_path={}",
                 server.id, server.name, server.jar_path, server.java_path);

        // Check if already running
        {
            let mut procs = self.processes.lock().unwrap();
            if let Some(child) = procs.get_mut(id) {
                match child.try_wait() {
                    Ok(Some(_)) => { procs.remove(id); } // Dead process, clean up
                    Ok(None) => return Err("服务器已在运行中".to_string()),
                    Err(_) => { procs.remove(id); }
                }
            }
        }

        let settings = self.get_app_settings();
        if settings.auto_accept_eula {
            let eula = std::path::Path::new(&server.path).join("eula.txt");
            let _ = std::fs::write(&eula, "# Auto-accepted by Sea Lantern\neula=true\n");
        }

        // 使用最简单的方式直接启动Java
        let mut cmd = Command::new(&server.java_path);
        cmd.arg(format!("-Xmx{}M", server.max_memory));
        cmd.arg(format!("-Xms{}M", server.min_memory));

        // 强制使用UTF-8编码，避免Windows上的中文乱码问题
        cmd.arg("-Dfile.encoding=UTF-8");
        cmd.arg("-Dsun.stdout.encoding=UTF-8");
        cmd.arg("-Dsun.stderr.encoding=UTF-8");

        let jvm = settings.default_jvm_args.trim();
        if !jvm.is_empty() {
            for arg in jvm.split_whitespace() {
                cmd.arg(arg);
            }
        }

        for arg in &server.jvm_args {
            cmd.arg(arg);
        }

        cmd.arg("-jar");

        // 由于JAR文件现在都在服务器目录下，直接使用文件名
        let jar_path_obj = std::path::Path::new(&server.jar_path);
        let jar_filename = jar_path_obj.file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| server.jar_path.clone());

        cmd.arg(&jar_filename);
        cmd.arg("nogui");

        cmd.current_dir(&server.path);

        // 使用文件重定向，避免piped导致的Java代理加载问题
        let log_file = std::path::Path::new(&server.path).join("latest.log");

        // 清空旧日志文件，避免读取历史日志
        let stdout_file = std::fs::OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&log_file)
            .map_err(|e| format!("无法创建日志文件: {}", e))?;

        let stderr_file = stdout_file.try_clone()
            .map_err(|e| format!("无法克隆文件句柄: {}", e))?;

        cmd.stdout(Stdio::from(stdout_file));
        cmd.stderr(Stdio::from(stderr_file));
        cmd.stdin(Stdio::piped());

        // 隐藏控制台窗口
        #[cfg(target_os = "windows")]
        {
            use std::os::windows::process::CommandExt;
            const CREATE_NO_WINDOW: u32 = 0x08000000;
            cmd.creation_flags(CREATE_NO_WINDOW);
        }

        let mut child = cmd.spawn().map_err(|e| format!("启动失败: {}", e))?;
        println!("Java进程已启动，PID: {:?}", child.id());

        self.processes.lock().unwrap().insert(id.to_string(), child);

        {
            let mut servers = self.servers.lock().unwrap();
            if let Some(s) = servers.iter_mut().find(|s| s.id == id) {
                s.last_started_at = Some(SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs());
            }
        }
        self.save();
        self.append_log(id, "[Sea Lantern] 服务器启动中...");

        // 启动日志读取线程
        let logs_ref = &self.logs as *const Mutex<HashMap<String, Vec<String>>>;
        let max_lines = settings.max_log_lines as usize;
        let lid = id.to_string();
        let ptr = logs_ref as usize;
        let ml = max_lines;
        let log_path = log_file.clone();

        std::thread::spawn(move || {
            use std::io::Seek;
            let mut pos = 0u64;
            let mut last_size = 0u64;

            loop {
                std::thread::sleep(std::time::Duration::from_millis(500));

                if let Ok(mut file) = std::fs::File::open(&log_path) {
                    if let Ok(metadata) = file.metadata() {
                        let len = metadata.len();

                        if len > last_size {
                            if file.seek(std::io::SeekFrom::Start(pos)).is_ok() {
                                let m = unsafe { &*(ptr as *const Mutex<HashMap<String, Vec<String>>>) };
                                let mut buffer = Vec::new();

                                if file.read_to_end(&mut buffer).is_ok() {
                                    let content = String::from_utf8_lossy(&buffer);
                                    for line in content.lines() {
                                        if !line.trim().is_empty() {
                                            if let Ok(mut l) = m.lock() {
                                                if let Some(v) = l.get_mut(&lid) {
                                                    v.push(line.to_string());
                                                    if v.len() > ml {
                                                        let d = v.len() - ml;
                                                        v.drain(0..d);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    pos = len;
                                }
                            }
                            last_size = len;
                        }
                    }
                }
            }
        });

        Ok(())
    }

    pub fn stop_server(&self, id: &str) -> Result<(), String> {
        // Check if actually running first
        let is_running = {
            let mut procs = self.processes.lock().unwrap();
            if let Some(child) = procs.get_mut(id) {
                match child.try_wait() {
                    Ok(Some(_)) => { procs.remove(id); false }
                    Ok(None) => true,
                    Err(_) => { procs.remove(id); false }
                }
            } else { false }
        };

        if !is_running {
            self.append_log(id, "[Sea Lantern] 服务器未运行");
            return Ok(());
        }

        // Send stop command
        self.append_log(id, "[Sea Lantern] 正在发送停止命令...");
        let _ = self.send_command(id, "stop");

        // Wait for graceful shutdown (up to 10 seconds)
        for _ in 0..20 {
            std::thread::sleep(std::time::Duration::from_millis(500));
            let mut procs = self.processes.lock().unwrap();
            if let Some(child) = procs.get_mut(id) {
                match child.try_wait() {
                    Ok(Some(_)) => {
                        procs.remove(id);
                        self.append_log(id, "[Sea Lantern] 服务器已正常停止");
                        return Ok(());
                    }
                    Ok(None) => {} // Still running
                    Err(_) => {
                        procs.remove(id);
                        return Ok(());
                    }
                }
            } else {
                self.append_log(id, "[Sea Lantern] 服务器已停止");
                return Ok(());
            }
        }

        // Force kill after timeout
        let mut procs = self.processes.lock().unwrap();
        if let Some(mut child) = procs.remove(id) {
            let _ = child.kill();
            let _ = child.wait();
            self.append_log(id, "[Sea Lantern] 服务器超时，已强制终止");
        }
        Ok(())
    }

    pub fn send_command(&self, id: &str, command: &str) -> Result<(), String> {
        let mut procs = self.processes.lock().unwrap();
        let child = procs.get_mut(id).ok_or_else(|| "服务器未运行".to_string())?;
        if let Some(ref mut stdin) = child.stdin {
            writeln!(stdin, "{}", command).map_err(|e| format!("发送失败: {}", e))?;
            stdin.flush().map_err(|e| format!("发送失败: {}", e))?;
        }
        Ok(())
    }

    pub fn get_server_list(&self) -> Vec<ServerInstance> {
        self.servers.lock().unwrap().clone()
    }

    pub fn get_server_status(&self, id: &str) -> ServerStatusInfo {
        let mut procs = self.processes.lock().unwrap();
        let is_running = if let Some(child) = procs.get_mut(id) {
            match child.try_wait() {
                Ok(Some(_)) => { procs.remove(id); false }
                Ok(None) => true,
                Err(_) => { procs.remove(id); false }
            }
        } else { false };
        ServerStatusInfo {
            id: id.to_string(),
            status: if is_running { ServerStatus::Running } else { ServerStatus::Stopped },
            pid: None, uptime: None,
        }
    }

    pub fn delete_server(&self, id: &str) -> Result<(), String> {
        // Only stop if actually running
        {
            let procs = self.processes.lock().unwrap();
            if procs.contains_key(id) {
                drop(procs);
                let _ = self.stop_server(id);
            }
        }
        self.servers.lock().unwrap().retain(|s| s.id != id);
        self.logs.lock().unwrap().remove(id);
        self.save();
        Ok(())
    }

    pub fn get_logs(&self, id: &str, since: usize) -> Vec<String> {
        let logs = self.logs.lock().unwrap();
        if let Some(v) = logs.get(id) {
            if since < v.len() { v[since..].to_vec() } else { Vec::new() }
        } else { Vec::new() }
    }

    fn append_log(&self, id: &str, msg: &str) {
        if let Ok(mut logs) = self.logs.lock() {
            if let Some(v) = logs.get_mut(id) { v.push(msg.to_string()); }
        }
    }

    pub fn stop_all_servers(&self) {
        let ids: Vec<String> = self.processes.lock().unwrap().keys().cloned().collect();
        for id in ids { let _ = self.stop_server(&id); }
    }
}

fn get_data_dir() -> String {
    // 使用软件根目录（可执行文件所在目录）
    if let Ok(exe_path) = std::env::current_exe() {
        if let Some(exe_dir) = exe_path.parent() {
            let data_dir = exe_dir.to_path_buf();
            println!("数据目录: {}", data_dir.display());
            return data_dir.to_string_lossy().to_string();
        }
    }

    // 如果获取失败，使用当前工作目录
    println!("警告: 无法获取可执行文件目录，使用当前目录");
    ".".to_string()
}

fn find_server_jar(modpack_path: &std::path::Path) -> Result<String, String> {
    // 常见的服务端JAR文件名模式
    let patterns = vec![
        "server.jar",
        "forge.jar",
        "fabric-server.jar",
        "minecraft_server.jar",
        "paper.jar",
        "spigot.jar",
        "purpur.jar",
    ];

    // 首先尝试精确匹配
    for pattern in &patterns {
        let jar_path = modpack_path.join(pattern);
        if jar_path.exists() {
            return Ok(jar_path.to_string_lossy().to_string());
        }
    }

    // 如果没有精确匹配，查找所有.jar文件
    let entries = std::fs::read_dir(modpack_path)
        .map_err(|e| format!("无法读取文件夹: {}", e))?;

    let mut jar_files = Vec::new();
    for entry in entries {
        if let Ok(entry) = entry {
            let path = entry.path();
            if path.is_file() {
                if let Some(ext) = path.extension() {
                    if ext == "jar" {
                        jar_files.push(path);
                    }
                }
            }
        }
    }

    if jar_files.is_empty() {
        return Err("整合包文件夹中未找到JAR文件".to_string());
    }

    // 如果只有一个JAR文件，直接使用
    if jar_files.len() == 1 {
        return Ok(jar_files[0].to_string_lossy().to_string());
    }

    // 如果有多个JAR文件，优先选择包含服务端关键词的文件
    for jar in &jar_files {
        if let Some(name) = jar.file_name() {
            let name_lower = name.to_string_lossy().to_lowercase();
            if name_lower.contains("server")
                || name_lower.contains("forge")
                || name_lower.contains("fabric")
                || name_lower.contains("mohist")
                || name_lower.contains("paper")
                || name_lower.contains("spigot")
                || name_lower.contains("purpur")
                || name_lower.contains("bukkit")
                || name_lower.contains("catserver")
                || name_lower.contains("arclight") {
                return Ok(jar.to_string_lossy().to_string());
            }
        }
    }

    // 如果都不匹配，返回第一个JAR文件
    Ok(jar_files[0].to_string_lossy().to_string())
}

fn load_servers(dir: &str) -> Vec<ServerInstance> {
    let p = std::path::Path::new(dir).join(DATA_FILE);
    if !p.exists() { return Vec::new(); }
    std::fs::read_to_string(&p).ok().and_then(|c| serde_json::from_str(&c).ok()).unwrap_or_default()
}
fn save_servers(dir: &str, servers: &[ServerInstance]) {
    let p = std::path::Path::new(dir).join(DATA_FILE);
    if let Ok(j) = serde_json::to_string_pretty(servers) { let _ = std::fs::write(&p, j); }
}

fn copy_dir_recursive(src: &std::path::Path, dst: &std::path::Path) -> std::io::Result<()> {
    if !dst.exists() {
        std::fs::create_dir_all(dst)?;
    }

    for entry in std::fs::read_dir(src)? {
        let entry = entry?;
        let src_path = entry.path();
        let dst_path = dst.join(entry.file_name());

        if src_path.is_dir() {
            copy_dir_recursive(&src_path, &dst_path)?;
        } else {
            std::fs::copy(&src_path, &dst_path)?;
        }
    }

    Ok(())
}
